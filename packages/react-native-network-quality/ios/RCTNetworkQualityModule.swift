// packages/react-native-network-quality/ios/RCTNetworkQualityModule.swift
//
//  TurboModule implementation for iOS.
//
//  This module implements the Spec interface generated by codegen
//  from `NativeNetworkQualityModule.ts`.
//
//  Responsibilities:
//  - Measure network quality using native iOS APIs
//  - Expose async methods to JavaScript via TurboModules
//  - Aggregate network metrics and return them as a Promise
//
//  Key iOS Constraints:
//  - Cellular RSSI is NOT available (Apple restriction)
//  - Wi-Fi RSSI requires NEHotspotNetwork (iOS 14.1+)
//  - Network state detection uses NWPathMonitor
//  - All timing values are returned in milliseconds
//
//  Architecture Overview:
//  1. Setup
//     - NWPathMonitor listens for network changes on a background queue
//
//  2. Measurement
//     - JS calls `measureNetwork()`
//     - Native layer orchestrates latency, bandwidth, and signal checks
//
//  3. Return
//     - Results are aggregated and returned via a Promise
//

import Foundation
import Network
import NetworkExtension
import React


// MARK: - Data Models

/// Network measurement data
struct MeasurementData {
    let timestamp: Double
    let networkType: String
    let cellularGeneration: String
    let wifiRssi: NSNumber?
    let cellularRssi: NSNumber?
    let latencyMs: NSNumber?
    let jitterMs: NSNumber?
    let downlinkMbps: NSNumber?
    let packetLossPercent: NSNumber?
    let isConnected: Bool
    let failureReason: String?

    func toDictionary() -> [String: Any] {
        return [
            "timestamp": timestamp,
            "networkType": networkType,
            "cellularGeneration": cellularGeneration,
            "wifiRssi": wifiRssi as Any,
            "cellularRssi": NSNull(),
            "latencyMs": latencyMs as Any,
            "jitterMs": jitterMs as Any,
            "downlinkMbps": downlinkMbps as Any,
            "packetLossPercent": packetLossPercent as Any,
            "isConnected": isConnected,
            "failureReason": failureReason as Any,
        ]
    }
}

// MARK: - TurboModule Implementation

@objc(RCTNetworkQualityModule)
/// This class implements the TurboModule interface for the NetworkQualityModule.
/// It is responsible for measuring the network quality using native iOS APIs.
/// It is also responsible for returning the results to the JavaScript layer.
/// @objc means this class can be used from Objective-C code.
class RCTNetworkQualityModule: NSObject {

    // MARK: - Properties

    /// Cached last measurement
    private var lastMeasurement: MeasurementData?

    /// Monitor network path changes
    private let pathMonitor: NWPathMonitor = NWPathMonitor()

    /// Background queue for network I/O
    private let queue = DispatchQueue.global(qos: .default)

    /// Current network path (updated in real-time)
    private var currentPath: Network.NWPath?

    // MARK: - Initialization

    /// constructor of the class
    /// Your class inherits from NSObject, which already has an init().
    override init() {
        super.init()
        /// → A new RCTNetworkQualityModule object is being created. → Call NSObject’s initializer (this is mandatory in Swift)
        setupPathMonitor()
    }

    /// deinit runs just before the object is destroyed (removed from memory). ✅ App is closed / killed, User swipes app away, OS kills app, process exits
    /// NWPathMonitor runs continuously on a background queue.     If you don’t cancel it, thread keeps running, memory leaks,  background work continues even after module is gone
    deinit {
        pathMonitor.cancel()
    }

    /// Setup network path monitoring
    /// only call once in the constructor
    /// Purpose : Start listening to network changes
    /// It tells whether connected / disconnected or wifi/cellular
    private func setupPathMonitor() {

        /// A handler that receives network path updates.
        /// If the closure(function) runs LATER → use [weak self]
        pathMonitor.pathUpdateHandler = { [weak self] path in
            self?.currentPath = path
        }

        /// Starts monitoring path changes, and sets a queue on which to deliver path events.
        pathMonitor.start(queue: queue)
    }

    // MARK: - Required TurboModule Methods

    @objc
    /// @objc means exposed to React native world, and false -> means it won't run on main thread, instead on background thread.
    /// static because React Native must decide the thread before the object exists.
    static func requiresMainQueueSetup() -> Bool {
        return false  // We do network I/O, run on background queue
    }

    // MARK: - Primary Measurement

    /// Async :Perform complete network quality measurement
    /// Orchestrates:
    /// 1. Connectivity check
    /// 2. Signal strength queries
    /// 3. Latency measurement (TCP handshake)
    /// 4. Throughput measurement (timed download)
    /// 5. Packet loss estimation (if extended=true)
    /// What React Native does internally
    ///
    /// React Native transforms your JS call into something like this:
    /// measureNetwork(options, resolveCallback, rejectCallback)
    /// These callbacks are created by the JS Promise runtime.
    /// But RN consumer calls it like this:
    /// const measurement = await NetworkQualityModule.measureNetwork({ extended: true, timeoutMs: 3000 });
    /// so since this a promise based method, we need to define to extra props(withResolver, withRejecter) while doing @objc
    @objc(measureNetwork:withResolver:withRejecter:)
    func measureNetwork(
        options: [String: Any]?,
        resolver: @escaping RCTPromiseResolveBlock,
        rejecter: @escaping RCTPromiseRejectBlock
    ) {
        /// Network tests are expensive, never block the main thread
        queue.async { [weak self] in
            
            /// unwrap self, if App backgrounded, JS bridge unloaded
            guard let self = self else { return }

            /// default extened options are true
            let extended = options?["extended"] as? Bool ?? true
            
            /// default timeoutms is 3000
            let timeoutMs = options?["timeoutMs"] as? Int ?? 3000
            
            let deadline = Date().addingTimeInterval(Double(timeoutMs) / 1000.0)

            // Step 1: Check connectivity
            /// returns
            /// {
            ///  isConnected: true,
            ///  networkType: "wifi",
            ///  cellularGeneration: "5g"
            /// }

            let status = self.getConnectivityStatusSync()

            
            if !status.isConnected {
                /// early exit if device is offline.
                let measurement = MeasurementData(
                    timestamp: Date().timeIntervalSince1970 * 1000,
                    networkType: "none",
                    cellularGeneration: "unknown",
                    wifiRssi: nil,
                    cellularRssi: nil,
                    latencyMs: nil,
                    jitterMs: nil,
                    downlinkMbps: nil,
                    packetLossPercent: nil,
                    isConnected: false,
                    failureReason: "Device is offline"
                )
                self.lastMeasurement = measurement
                resolver(measurement.toDictionary())
                return
            }

            // Step 2: Get Wi-Fi RSSI, since iOS does not allow cellular RSSI, only Wi-Fi
            let wifiRssi = self.getWifiRssiSync()

            // Step 3: Measure latency
            let latencyResult = self.measureLatencySync(timeoutMs: 500, before: deadline)

            // Step 4: Measure throughput
            let throughput = self.measureThroughputSync(
                durationMs: 2000,
                timeoutMs: 5000,
                before: deadline
            )
            
            // Step 5: Measure packet loss (if extended)
            var packetLoss: NSNumber? = nil
            if extended {
                packetLoss = self.measurePacketLossSync(
                    attemptCount: 10,
                    timeoutMs: 500,
                    before: deadline
                )
            }

            // Step 6: Aggregate and return
            let measurement = MeasurementData(
                timestamp: Date().timeIntervalSince1970 * 1000,
                networkType: status.networkType,
                cellularGeneration: status.cellularGeneration,
                wifiRssi: wifiRssi,
                cellularRssi: nil,  /// iOS doesn't expose cellular RSSI
                latencyMs: latencyResult.latencyMs,
                jitterMs: latencyResult.jitterMs,
                downlinkMbps: throughput?.downlinkMbps,
                packetLossPercent: packetLoss,
                isConnected: status.isConnected,
                failureReason: nil
            )

            self.lastMeasurement = measurement
            resolver(measurement.toDictionary())
        }
    }

    // MARK: - State Queries (Sync)

    @objc(getLastMeasurement)
    func getLastMeasurement() -> [String: Any]? {
        guard let last = lastMeasurement else { return nil }
        return last.toDictionary()
    }

    @objc(getConnectivityStatus)
    func getConnectivityStatus() -> [String: Any] {
        let status = getConnectivityStatusSync()
        return [
            "isConnected": status.isConnected,
            "networkType": status.networkType,
            "cellularGeneration": status.cellularGeneration,
        ]
    }

    @objc(getWifiRssi)
    func getWifiRssi() -> NSNumber? {
        return getWifiRssiSync()
    }

    @objc(getCellularRssi)
    func getCellularRssi() -> NSNumber? {
        return nil  // iOS doesn't expose cellular RSSI
    }

    // MARK: - Individual Measurements

    @objc(measureLatency:withResolver:withRejecter:)
    func measureLatency(
        options: [String: Any]?,
        resolver: @escaping RCTPromiseResolveBlock,
        rejecter: @escaping RCTPromiseRejectBlock
    ) {
        queue.async { [weak self] in
            let sampleCount = options?["sampleCount"] as? Int ?? 3
            let timeoutMs = options?["timeoutMs"] as? Int ?? 500
            let deadline = Date().addingTimeInterval(Double(timeoutMs * sampleCount) / 1000.0)

            let result = self?.measureLatencySync(timeoutMs: timeoutMs, before: deadline)
            resolver([
                "latencyMs": result?.latencyMs as Any,
                "jitterMs": result?.jitterMs as Any,
            ])
        }
    }

    @objc(measureThroughput:withResolver:withRejecter:)
    func measureThroughput(
        options: [String: Any]?,
        resolver: @escaping RCTPromiseResolveBlock,
        rejecter: @escaping RCTPromiseRejectBlock
    ) {
        queue.async { [weak self] in
            let durationMs = options?["durationMs"] as? Int ?? 2000
            let timeoutMs = options?["timeoutMs"] as? Int ?? 5000
            let deadline = Date().addingTimeInterval(Double(timeoutMs) / 1000.0)

            let result = self?.measureThroughputSync(
                durationMs: durationMs,
                timeoutMs: timeoutMs,
                before: deadline
            )
            resolver(result?.downlinkMbps as Any)
        }
    }

    @objc(measurePacketLoss:withResolver:withRejecter:)
    func measurePacketLoss(
        options: [String: Any]?,
        resolver: @escaping RCTPromiseResolveBlock,
        rejecter: @escaping RCTPromiseRejectBlock
    ) {
        queue.async { [weak self] in
            let attemptCount = options?["attemptCount"] as? Int ?? 10
            let timeoutMs = options?["timeoutMs"] as? Int ?? 500
            let deadline = Date().addingTimeInterval(Double(timeoutMs * attemptCount) / 1000.0)

            let loss = self?.measurePacketLossSync(
                attemptCount: attemptCount,
                timeoutMs: timeoutMs,
                before: deadline
            )
            resolver(loss as Any)
        }
    }

    // MARK: - Implementation Details

    /// Get connectivity status synchronously
    private func getConnectivityStatusSync() -> (
        isConnected: Bool, networkType: String, cellularGeneration: String
    ) {
        guard let path: NWPath = currentPath else {
            return (false, "unknown", "unknown")
        }

        let isConnected = path.status == .satisfied
        var networkType: String = "none"
        var cellularGeneration = "unknown"

        if path.usesInterfaceType(.wifi) {
            networkType = "wifi"
        } else if path.usesInterfaceType(.cellular) {
            networkType = "cellular"
        } else if path.usesInterfaceType(.wiredEthernet) {
            networkType = "wifi"
        } else {
            networkType = isConnected ? "unknown" : "none"
        }

        return (isConnected, networkType, cellularGeneration)
    }

    /// Get Wi-Fi signal strength (RSSI in dBm)
    private func getWifiRssiSync() -> NSNumber? {
        // iOS 14.1+ only
        if #available(iOS 14.1, *) {
            guard let network = try? NEHotspotNetwork.fetchCurrent() else {
                return nil
            }
            // Note: RSSI via private API - returns nil for now (App Store safe)
            return nil
        }
        return nil
    }

    /// Measure latency via TCP handshake
    private func measureLatencySync(
        timeoutMs: Int,
        before deadline: Date
    ) -> (latencyMs: NSNumber?, jitterMs: NSNumber?) {
        /// cloudflare -> 1.1.1.1 and 443 -> for https
        let endpoint = NWEndpoint.hostPort(host: "1.1.1.1", port: 443)
        
        /// Stores multiple round-trip times.
        var rtts: [Double] = []

        /// do three attempts
        for _ in 0..<3 {
            /// to make sure we are attempting before deadline.
            guard Date() < deadline else { break }

            let startTime = Date()
            let connection = NWConnection(to: endpoint, using: .tcp)
            
            /// Allows blocking until handshake completes.
            let group = DispatchGroup()
            group.enter()

            var success = false

            connection.stateUpdateHandler = { state in
                if state == .ready {
                    success = true
                    /// leaves blocking here
                    group.leave()
                }
            }

            connection.start(queue: queue)
            _ = group.wait(timeout: .milliseconds(timeoutMs))

            let elapsed = Date().timeIntervalSince(startTime) * 1000
            
            /// cleanup
            connection.cancel()

            if success {
                rtts.append(elapsed)
            }
        }

        /// if we dont exit early, ahead we are going to divide by rtts.count and if it becomes zero, it will crash at division.
        guard !rtts.isEmpty else {
            return (nil, nil)
        }

        /// reduce(0, +) -> Start from 0 and keep adding every RTT value
        /// Double(rtts.count) to keep the same types as of rtts
        /// simply total rtts/ number of rtts
        let avg = rtts.reduce(0, +) / Double(rtts.count)
        
        /// variance = Σ (RTT − avg)² / N
        /// $0 -> short hand for element
        /// pow($0 - avg, 2) -> (element - avg)²
        let variance = rtts.map { pow($0 - avg, 2) }.reduce(0, +) / Double(rtts.count)
        
        /// So when you say “jitter”, you’re saying:
        /// “How much RTT fluctuates around its average”
        let jitter = rtts.count > 1 ? sqrt(variance) : nil

        return (NSNumber(value: avg), jitter.map { NSNumber(value: $0) })
    }

    /// Measure throughput via timed download
    private func measureThroughputSync(
        durationMs: Int,
        timeoutMs: Int,
        before deadline: Date
    ) -> (downlinkMbps: NSNumber?)? {
        let urlString = "https://speed.cloudflare.com/__down?bytes=1000000000"
        guard let url = URL(string: urlString) else { return nil }

        var request = URLRequest(url: url)
        request.timeoutInterval = TimeInterval(timeoutMs) / 1000.0

        let startTime = Date()
        var bytesReceived: Int64 = 0
        let semaphore = DispatchSemaphore(value: 0)
        var throughputMbps: Double? = nil

        let task = URLSession.shared.dataTask(with: request) { data, _, _ in
            if let data = data {
                bytesReceived = Int64(data.count)
            }

            let elapsed = Date().timeIntervalSince(startTime)
            if elapsed > 0 && bytesReceived > 0 {
                let bits = Double(bytesReceived) * 8
                throughputMbps = (bits / 1_000_000) / elapsed
            }

            semaphore.signal()
        }

        task.resume()
        _ = semaphore.wait(timeout: .milliseconds(timeoutMs))
        task.cancel()

        guard let mbps = throughputMbps else {
            return (nil)
        }

        return (NSNumber(value: mbps))
    }

    /// Estimate packet loss via HTTP timeouts
    private func measurePacketLossSync(
        attemptCount: Int,
        timeoutMs: Int,
        before deadline: Date
    ) -> NSNumber? {
        let endpoint = "https://1.1.1.1/dns-query"
        guard let url = URL(string: endpoint) else { return nil }

        var failures = 0

        for _ in 0..<attemptCount {
            guard Date() < deadline else { break }

            var request = URLRequest(url: url)
            request.timeoutInterval = TimeInterval(timeoutMs) / 1000.0

            let semaphore = DispatchSemaphore(value: 0)
            var succeeded = false

            let task = URLSession.shared.dataTask(with: request) { _, _, error in
                succeeded = error == nil
                semaphore.signal()
            }

            task.resume()
            _ = semaphore.wait(timeout: .milliseconds(timeoutMs * 2))

            if !succeeded {
                failures += 1
            }

            task.cancel()
        }

        let lossPercent = (Double(failures) / Double(attemptCount)) * 100
        return NSNumber(value: lossPercent)
    }
}
