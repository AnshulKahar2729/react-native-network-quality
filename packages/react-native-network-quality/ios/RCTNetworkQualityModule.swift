// packages/react-native-network-quality/ios/RCTNetworkQualityModule.swift
//
//  TurboModule implementation for iOS.
//
//  This module implements the Spec interface generated by codegen
//  from `NativeNetworkQualityModule.ts`.
//
//  Responsibilities:
//  - Measure network quality using native iOS APIs
//  - Expose async methods to JavaScript via TurboModules
//  - Aggregate network metrics and return them as a Promise
//
//  Key iOS Constraints:
//  - Cellular and Wi‑Fi RSSI are NOT available (Apple restriction)
//  - Network state detection uses NWPathMonitor
//  - All timing values are returned in milliseconds
//
//  Architecture Overview:
//  1. Setup
//     - NWPathMonitor listens for network changes on a background queue
//
//  2. Measurement
//     - JS calls `measureNetwork()`
//     - Native layer orchestrates latency, bandwidth, and signal checks
//
//  3. Return
//     - Results are aggregated and returned via a Promise
//

import Foundation
import Network
import NetworkExtension
import React

// MARK: - Data Models

/// Network measurement data
struct MeasurementData {
    let timestamp: Double
    let networkType: String
    let cellularGeneration: String
    let latencyMs: NSNumber?
    let jitterMs: NSNumber?
    let downlinkMbps: NSNumber?
    let packetLossPercent: NSNumber?
    let isConnected: Bool
    let failureReason: String?

    func toDictionary() -> [String: Any] {
        return [
            "timestamp": timestamp,
            "networkType": networkType,
            "cellularGeneration": cellularGeneration,
            "latencyMs": latencyMs as Any,
            "jitterMs": jitterMs as Any,
            "downlinkMbps": downlinkMbps as Any,
            "packetLossPercent": packetLossPercent as Any,
            "isConnected": isConnected,
            "failureReason": failureReason as Any,
        ]
    }
}

// MARK: - TurboModule Implementation

@objc(RCTNetworkQualityModuleImpl)
/// This class implements the actual network quality measurement logic.
/// It is called by the ObjC++ wrapper (RCTNetworkQualityModule.mm).
class RCTNetworkQualityModuleImpl: NSObject {

    // MARK: - Properties

    /// Cached last measurement
    private var lastMeasurement: MeasurementData?

    /// Monitor network path changes
    private let pathMonitor: NWPathMonitor = NWPathMonitor()

    /// Background queue for network I/O
    private let queue = DispatchQueue.global(qos: .default)

    /// Current network path (updated in real-time)
    private var currentPath: Network.NWPath?

    // MARK: - Initialization

    /// constructor of the class
    /// Your class inherits from NSObject, which already has an init().
    override init() {
        super.init()
        /// → A new RCTNetworkQualityModule object is being created. → Call NSObject’s initializer (this is mandatory in Swift)
        setupPathMonitor()
    }

    /// deinit runs just before the object is destroyed (removed from memory). ✅ App is closed / killed, User swipes app away, OS kills app, process exits
    /// NWPathMonitor runs continuously on a background queue.     If you don’t cancel it, thread keeps running, memory leaks,  background work continues even after module is gone
    deinit {
        pathMonitor.cancel()
    }

    /// Setup network path monitoring
    /// only call once in the constructor
    /// Purpose : Start listening to network changes
    /// It tells whether connected / disconnected or wifi/cellular
    private func setupPathMonitor() {

        /// A handler that receives network path updates.
        /// If the closure(function) runs LATER → use [weak self]
        pathMonitor.pathUpdateHandler = { [weak self] path in
            self?.currentPath = path
        }

        /// Starts monitoring path changes, and sets a queue on which to deliver path events.
        pathMonitor.start(queue: queue)
    }

    // MARK: - Implementation Methods

    // MARK: - Primary Measurement

    /// Async :Perform complete network quality measurement
    /// Orchestrates:
    /// 1. Connectivity check
    /// 2. Signal strength queries
    /// 3. Latency measurement (TCP handshake)
    /// 4. Throughput measurement (timed download)
    /// 5. Packet loss estimation (if extended=true)
    /// What React Native does internally
    ///
    /// React Native transforms your JS call into something like this:
    /// measureNetwork(options, resolveCallback, rejectCallback)
    /// These callbacks are created by the JS Promise runtime.
    /// But RN consumer calls it like this:
    /// const measurement = await NetworkQualityModule.measureNetwork({ extended: true, timeoutMs: 3000 });
    /// so since this a promise based method, we need to define to extra props(withResolver, withRejecter) while doing @objc
    @objc
    func measureNetwork(
        _ options: [String: Any]?,
        resolve resolver: @escaping RCTPromiseResolveBlock,
        reject rejecter: @escaping RCTPromiseRejectBlock
    ) {
        /// Network tests are expensive, never block the main thread
        queue.async { [weak self] in

            /// unwrap self, if App backgrounded, JS bridge unloaded
            guard let self = self else { return }

            /// default extened options are true
            let extended = options?["extended"] as? Bool ?? true

            /// default timeoutms is 3000
            let timeoutMs = options?["timeoutMs"] as? Int ?? 3000

            let deadline = Date().addingTimeInterval(Double(timeoutMs) / 1000.0)

            // Step 1: Check connectivity
            /// returns
            /// {
            ///  isConnected: true,
            ///  networkType: "wifi",
            ///  cellularGeneration: "5g"
            /// }

            let status = self.getConnectivityStatusSync()

            if !status.isConnected {
                /// early exit if device is offline.
                let measurement = MeasurementData(
                    timestamp: Date().timeIntervalSince1970 * 1000,
                    networkType: "none",
                    cellularGeneration: "unknown",
                    latencyMs: nil,
                    jitterMs: nil,
                    downlinkMbps: nil,
                    packetLossPercent: nil,
                    isConnected: false,
                    failureReason: "Device is offline"
                )
                self.lastMeasurement = measurement
                resolver(measurement.toDictionary())
                return
            }

            // Step 2: Measure latency
            let latencyResult = self.measureLatencySync(timeoutMs: 500, before: deadline)

            // Step 3: Measure throughput
            let throughput = self.measureThroughputSync(
                durationMs: 2000,
                timeoutMs: 5000,
                before: deadline
            )

            // Step 4: Measure packet loss (if extended)
            var packetLoss: NSNumber? = nil
            if extended {
                packetLoss = self.measurePacketLossSync(
                    attemptCount: 10,
                    timeoutMs: 500,
                    before: deadline
                )
            }

            // Step 5: Aggregate and return
            let measurement = MeasurementData(
                timestamp: Date().timeIntervalSince1970 * 1000,
                networkType: status.networkType,
                cellularGeneration: status.cellularGeneration,
                latencyMs: latencyResult.latencyMs,
                jitterMs: latencyResult.jitterMs,
                downlinkMbps: throughput,
                packetLossPercent: packetLoss,
                isConnected: status.isConnected,
                failureReason: nil
            )

            self.lastMeasurement = measurement
            resolver(measurement.toDictionary())
        }
    }

    // MARK: - State Queries (Sync)

    @objc
    func getLastMeasurement() -> [String: Any]? {
        guard let last = lastMeasurement else { return nil }
        return last.toDictionary()
    }

    @objc
    func getConnectivityStatus() -> [String: Any] {
        let status = getConnectivityStatusSync()
        return [
            "isConnected": status.isConnected,
            "networkType": status.networkType,
            "cellularGeneration": status.cellularGeneration,
        ]
    }

    // MARK: - Individual Measurements

    @objc
    func measureLatency(
        _ options: [String: Any]?,
        resolve resolver: @escaping RCTPromiseResolveBlock,
        reject rejecter: @escaping RCTPromiseRejectBlock
    ) {
        queue.async { [weak self] in
            let sampleCount = options?["sampleCount"] as? Int ?? 3
            let timeoutMs = options?["timeoutMs"] as? Int ?? 500
            let deadline = Date().addingTimeInterval(Double(timeoutMs * sampleCount) / 1000.0)

            let result = self?.measureLatencySync(timeoutMs: timeoutMs, before: deadline)
            resolver([
                "latencyMs": result?.latencyMs as Any,
                "jitterMs": result?.jitterMs as Any,
            ])
        }
    }

    @objc
    func measureThroughput(
        _ options: [String: Any]?,
        resolve resolver: @escaping RCTPromiseResolveBlock,
        reject rejecter: @escaping RCTPromiseRejectBlock
    ) {
        queue.async { [weak self] in
            let durationMs = options?["durationMs"] as? Int ?? 2000
            let timeoutMs = options?["timeoutMs"] as? Int ?? 5000
            let deadline = Date().addingTimeInterval(Double(timeoutMs) / 1000.0)

            let result = self?.measureThroughputSync(
                durationMs: durationMs,
                timeoutMs: timeoutMs,
                before: deadline
            )
            resolver(result as Any)
        }
    }

    @objc
    func measurePacketLoss(
        _ options: [String: Any]?,
        resolve resolver: @escaping RCTPromiseResolveBlock,
        reject rejecter: @escaping RCTPromiseRejectBlock
    ) {
        queue.async { [weak self] in
            let attemptCount = options?["attemptCount"] as? Int ?? 10
            let timeoutMs = options?["timeoutMs"] as? Int ?? 500
            let deadline = Date().addingTimeInterval(Double(timeoutMs * attemptCount) / 1000.0)

            let loss = self?.measurePacketLossSync(
                attemptCount: attemptCount,
                timeoutMs: timeoutMs,
                before: deadline
            )
            resolver(loss as Any)
        }
    }

    // MARK: - Implementation Details

    /// Get connectivity status synchronously
    private func getConnectivityStatusSync() -> (
        isConnected: Bool, networkType: String, cellularGeneration: String
    ) {
        guard let path = currentPath else {
            return (false, "unknown", "unknown")
        }

        let isConnected = path.status == .satisfied
        var networkType: String = "none"
        var cellularGeneration = "unknown"

        if path.usesInterfaceType(NWInterface.InterfaceType.wifi) {
            networkType = "wifi"
        } else if path.usesInterfaceType(NWInterface.InterfaceType.cellular) {
            networkType = "cellular"
        } else if path.usesInterfaceType(NWInterface.InterfaceType.wiredEthernet) {
            networkType = "wifi"
        } else {
            networkType = isConnected ? "unknown" : "none"
        }

        return (isConnected, networkType, cellularGeneration)
    }

    /// Measure latency via TCP handshake
    private func measureLatencySync(
        timeoutMs: Int,
        before deadline: Date
    ) -> (latencyMs: NSNumber?, jitterMs: NSNumber?) {
        /// cloudflare -> 1.1.1.1 and 443 -> for https
        let endpoint = NWEndpoint.hostPort(host: "1.1.1.1", port: 443)

        /// Stores multiple round-trip times.
        var rtts: [Double] = []

        /// do three attempts
        for _ in 0..<3 {
            /// to make sure we are attempting before deadline.
            guard Date() < deadline else { break }

            let startTime = Date()
            let connection = NWConnection(to: endpoint, using: .tcp)

            /// Allows blocking until handshake completes.
            let group = DispatchGroup()
            group.enter()

            var success = false

            connection.stateUpdateHandler = { state in
                if state == .ready {
                    success = true
                    /// leaves blocking here
                    group.leave()
                }
            }

            connection.start(queue: queue)
            _ = group.wait(timeout: .now() + .milliseconds(timeoutMs))

            let elapsed = Date().timeIntervalSince(startTime) * 1000

            /// cleanup
            connection.cancel()

            if success {
                rtts.append(elapsed)
            }
        }

        /// if we dont exit early, ahead we are going to divide by rtts.count and if it becomes zero, it will crash at division.
        guard !rtts.isEmpty else {
            return (latencyMs: nil, jitterMs: nil)
        }

        /// reduce(0, +) -> Start from 0 and keep adding every RTT value
        /// Double(rtts.count) to keep the same types as of rtts
        /// simply total rtts/ number of rtts
        let avg = rtts.reduce(0, +) / Double(rtts.count)

        /// variance = Σ (RTT − avg)² / N
        /// $0 -> short hand for element
        /// pow($0 - avg, 2) -> (element - avg)²
        let variance = rtts.map { pow($0 - avg, 2) }.reduce(0, +) / Double(rtts.count)

        /// So when you say “jitter”, you’re saying:
        /// “How much RTT fluctuates around its average”
        let jitter = rtts.count > 1 ? sqrt(variance) : nil

        return (latencyMs: NSNumber(value: avg), jitterMs: jitter.map { NSNumber(value: $0) })
    }

    /// Measure throughput via timed download
    /// Measure throughput via timed download
    /// Measure throughput via timed download with optimized file size
    private func measureThroughputSync(
        durationMs: Int,
        timeoutMs: Int,
        before deadline: Date
    ) -> NSNumber? {
        // Start with 10MB, adjust based on network speed
        var fileSize = 10_000_000  // 10MB in bytes

        print(
            "[Throughput] Starting measurement - Duration: \(durationMs)ms, Timeout: \(timeoutMs)ms"
        )
        print("[Throughput] Target file size: \(fileSize / (1024 * 1024))MB")

        let urlString = "https://speed.cloudflare.com/__down?bytes=\(fileSize)"
        guard let url = URL(string: urlString) else {
            print("[Throughput] ERROR: Failed to create URL")
            return nil
        }
        print("[Throughput] URL created: \(url.absoluteString)")

        var request = URLRequest(url: url)
        request.timeoutInterval = TimeInterval(timeoutMs) / 1000.0
        print("[Throughput] Request timeout set to: \(request.timeoutInterval)s")

        let startTime = Date()
        var bytesReceived: Int64 = 0
        let semaphore = DispatchSemaphore(value: 0)
        var throughputMbps: Double? = nil
        var errorDescription: String? = nil

        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            let elapsed = Date().timeIntervalSince(startTime)
            print("[Throughput] Download completed - Elapsed: \(String(format: "%.3f", elapsed))s")

            if let error = error {
                let nsError = error as NSError
                // -999 is cancellation, which is expected
                if nsError.code != -999 {
                    errorDescription = error.localizedDescription
                    print(
                        "[Throughput] ERROR: \(error.localizedDescription) (Code: \(nsError.code))")
                }
            }

            if let httpResponse = response as? HTTPURLResponse {
                print("[Throughput] HTTP Status Code: \(httpResponse.statusCode)")
            }

            if let data = data {
                bytesReceived = Int64(data.count)
                let dataMB = String(format: "%.2f", Double(bytesReceived) / (1024 * 1024))
                print("[Throughput] Bytes received: \(bytesReceived) (\(dataMB) MB)")
            } else {
                print("[Throughput] WARNING: No data received")
            }

            if elapsed > 0 && bytesReceived > 0 {
                let bits = Double(bytesReceived) * 8
                throughputMbps = (bits / 1_000_000) / elapsed
                let throughputFormatted = String(format: "%.2f", throughputMbps ?? 0)
                print("[Throughput] Calculation - Mbps: \(throughputFormatted)")
            } else {
                print("[Throughput] WARNING: Cannot calculate throughput")
            }

            semaphore.signal()
        }

        print("[Throughput] Starting download...")
        task.resume()

        let waitResult = semaphore.wait(timeout: .now() + .milliseconds(timeoutMs))

        if waitResult == .timedOut {
            print("[Throughput] WARNING: Download timed out after \(timeoutMs)ms")
            task.cancel()
        }

        guard let mbps = throughputMbps else {
            print(
                "[Throughput] ERROR: No throughput calculated. Error: \(errorDescription ?? "Unknown")"
            )
            return nil
        }

        print("[Throughput] SUCCESS: Throughput = \(String(format: "%.2f", mbps)) Mbps")
        return NSNumber(value: mbps)
    }

    /// Estimate packet loss via HTTP timeouts
    /// Estimate packet loss via HTTP timeouts (Optimized)
    /// Estimate packet loss via HTTP timeouts (Improved)
    private func measurePacketLossSync(
        attemptCount: Int,
        timeoutMs: Int,
        before deadline: Date
    ) -> NSNumber? {
        // Use a proper endpoint that accepts GET requests without parameters
        let endpoint = "https://www.google.com/generate_204"
        print(
            "[PacketLoss] Starting measurement - Attempts: \(attemptCount), Timeout: \(timeoutMs)ms"
        )

        guard let url = URL(string: endpoint) else {
            print("[PacketLoss] ERROR: Failed to create URL from \(endpoint)")
            return nil
        }
        print("[PacketLoss] URL created: \(url.absoluteString)")

        var failures = 0
        let startTime = Date()

        for attempt in 0..<attemptCount {
            let elapsedMs = Date().timeIntervalSince(startTime) * 1000
            print(
                "[PacketLoss] Attempt \(attempt + 1)/\(attemptCount) - Elapsed: \(String(format: "%.0f", elapsedMs))ms"
            )

            guard Date() < deadline else {
                print("[PacketLoss] WARNING: Deadline reached, stopping attempts")
                break
            }

            var request = URLRequest(url: url)
            request.timeoutInterval = TimeInterval(timeoutMs) / 1000.0

            let semaphore = DispatchSemaphore(value: 0)
            var succeeded = false
            var taskStartTime = Date()

            let task = URLSession.shared.dataTask(with: request) { data, response, error in
                let taskElapsed = Date().timeIntervalSince(taskStartTime)

                if let error = error {
                    let nsError = error as NSError
                    succeeded = false
                    print(
                        "[PacketLoss]   ERROR: \(error.localizedDescription) (Code: \(nsError.code)) - Elapsed: \(String(format: "%.3f", taskElapsed))s"
                    )
                } else {
                    succeeded = true
                    print(
                        "[PacketLoss]   SUCCESS - Elapsed: \(String(format: "%.3f", taskElapsed))s")
                }

                if let httpResponse = response as? HTTPURLResponse {
                    print("[PacketLoss]   HTTP Status: \(httpResponse.statusCode)")
                    // 204 No Content is expected response
                    if httpResponse.statusCode == 204 {
                        print("[PacketLoss]   ✓ Expected 204 response")
                    }
                }

                semaphore.signal()
            }

            taskStartTime = Date()
            task.resume()

            // Wait for response with the specified timeout
            let waitResult = semaphore.wait(timeout: .now() + .milliseconds(timeoutMs))

            if waitResult == .timedOut {
                print("[PacketLoss]   TIMEOUT: No response within \(timeoutMs)ms")
                succeeded = false
                task.cancel()
            }

            if !succeeded {
                failures += 1
                print("[PacketLoss]   Result: FAILED (Total failures: \(failures))")
            } else {
                print("[PacketLoss]   Result: SUCCESS")
            }
        }

        let totalTime = Date().timeIntervalSince(startTime)
        print("[PacketLoss] Total measurement time: \(String(format: "%.3f", totalTime))s")
        print("[PacketLoss] Total failures: \(failures)/\(attemptCount)")

        let lossPercent = (Double(failures) / Double(attemptCount)) * 100
        print("[PacketLoss] FINAL RESULT: Packet loss = \(String(format: "%.2f", lossPercent))%")

        return NSNumber(value: lossPercent)
    }
}
